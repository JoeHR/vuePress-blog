# javascript

::: info

设计原则（SOLID）是设计模式的指导理论，它可以帮助我们规避不良的软件设计。它指代的五个基本原则分别是：

- 单一功能原则 (Single Responsibility Principle)
  + 一个程序只做一件事
  + 如果功能过于复杂就拆分开，每个部分保持独立
- 开放封闭原则 (Open Closed Principle)
  + 对扩展开放，对修改封闭
  + 增加需求时，扩展新代码，而非修改已有的代码
- 里式替换原则 (Lishov Substitution Principle)
  + 子类能覆盖父类
  + 父类能出现的地方子类就能出现
- 接口隔离原则 (Interface Segregation Principle)
  + 保持接口的单一独立
  + 类似单一职责原则，这里更关注接口
- 依赖反转原则 (Dependency Inversion Principle)
  + 面向接口编程，依赖于抽象而不依赖于具体
  + 使用方只关注接口而不关注具体类的实现

在 javascript 设计模式中，主要用到的设计模式基本都围绕 "单一功能" 和 "开放封闭" 这两个原则来展开

:::

**设计模式的核心思想——封装变化**

设计模式出现的背景，是软件设计的复杂度日益飙升。软件设计越来越复杂的“罪魁祸首”，就是变化。

这一点相信大家不难理解——如果说我们写一个业务，这个业务是一潭死水，初始版本是 1.0，100 年后还是 1.0，不接受任何迭代和优化，那么这个业务几乎可以随便写。反正只要实现功能就行了，完全不需要考虑可维护性、可扩展性。

但在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响最小化 —— 将变与不变分离，确保变化的部分灵活、不变的部分稳定。

这个过程，就叫“封装变化”；这样的代码，就是我们所谓的“健壮”的代码，它可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的代码

**设计模式的“术”**

所谓“术”，其实就是指二十年前 GOF 提出的最经典的 23 种设计模式。二十年前，四位程序员前辈（Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides）通过编写《设计模式：可复用面向对象软件的基础》这本书，阐述了设计模式领域的开创性成果。在这本书中，将 23 种设计模式按照“创建型”、“行为型”和“结构型”进行划分：

<table>
   <tr>
      <td rowspan="23">23种设计模式</td>
      <td rowspan="5">
          创建型
          (封装创建对象过程中的变化,将创建对象的过程进行抽离)
       </td>
      <td>单例模式</td>
   </tr>
   <tr>
      <td>原型模式</td>
   </tr>
   <tr>
      <td>构造器模式</td>
   </tr>
   <tr>
      <td>工厂模式</td>
   </tr>
   <tr>
      <td>抽象工厂模式</td>
   </tr>
   <tr>
      <td rowspan="7">
          结构型
          (封装对象之间组合方式的变化；灵活表达对象间的配合与依赖关系)
       </td>
      <td>桥接模式</td>
   </tr>
   <tr>
      <td>外观模式</td>
   </tr>
   <tr>
      <td>组合模式</td>
   </tr>
   <tr>
      <td>装饰器模式</td>
   </tr>
   <tr>
      <td>适配器模式</td>
   </tr>
   <tr>
      <td>代理模式</td>
   </tr>
   <tr>
      <td>享元模式</td>
   </tr>
   <tr>
      <td rowspan="11">
          行为型(将对象千变万化的行为进行抽离，
          确保我们能够更安全、更方便的对行为进行更改)
       </td>
      <td>迭代器模式</td>
   </tr>
   <tr>
      <td>解释器模式</td>
   </tr>
   <tr>
      <td>观察者模式</td>
   </tr>
   <tr>
      <td>中介者模式</td>
   </tr>
   <tr>
      <td>访问者模式</td>
   </tr>
   <tr>
      <td>状态模式</td>
   </tr>
   <tr>
      <td>备忘录模式</td>
   </tr>
   <tr>
      <td>策略模式</td>
   </tr>
   <tr>
      <td>模板方法模式</td>
   </tr>
   <tr>
      <td>职责链模式</td>
   </tr>
   <tr>
      <td>命令模式</td>
   </tr>
</table>

## 创建型-设计模式

### 工厂模式 & 抽象工厂

> 工厂模式其实就是将创建对象的过程单独封装，目的是抽象不同构造函数（类）之间的变与不变

根据 抽象程度的不同可以分为： 简单工厂，工厂方法和抽象工厂

::: info

场景1：李雷 接到一个需求要做 一个员工信息录入系统，需要录入每个人的姓名，年龄和职位，今天提测，先把部门的500人录入系统看看功能。李雷心想，500个对象字面量，要死要死，还好我有构造函数。于是李雷写出了一个可以自动创建用户的 User 函数

:::

<pre style="user-select:none;">
  function User(name , age, career) {
      this.name = name
      this.age = age
      this.career = career
  }
</pre>

实际上，李雷写的这个 User 函数就是一个构造器。接下来，就是让程序自动的读取数据库里面一行行的员工信息，然后把拿到的姓名、年龄等字段塞进 User函数，进行一个简单的调用

<pre style="user-select:none;">
  const user = new User(name,age,career)
</pre>

像 User 这样当新建对象的内存被分配后，用来初始化该对象的特殊函数，就叫做构造器。在创建一个*user*过程中，很明显，变化的是每个 user 的姓名，年龄，工种这些值，这是每个 user 的 **个性**,不变的是 每个 user 都具有  姓名、年龄 和工种 这些属性，这是每个 user 的 **共性**


::: info

场景2：李雷的新需求，老板说这个系统录的信息也太简单了，程序员跟产品经理之间的区别一个简单的 carerr 字段怎么能说得清？我要去这个系统具备**给不同工种分配职责说明**的功能。也就是所，要给每个工种的用户加上一个个性化的字段，来描述他们的工作内容

:::
