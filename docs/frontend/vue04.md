## Vue-Router  中的 hash 模式 和 history 模式的区别

- 最明显的显性区别： `hash`模式的 `url`中会夹杂着 `#`符号，而 `history`模式没有

- 底层实现不同：

  `hash`模式 是基于 浏览器的 `onhashchange`事件（监听 `location.hash`的改变）实现

  `history`模式是基于 `HTML5 history`新提供的两个方法：`pushState()`可以改变`url`地址且不会发送请求，`replaceState()`方法可以读取历史记录栈，还可以对浏览器记录进行修改 

  

## 介绍一下虚拟DOM

虚拟 `Dom` 本质就是用一个原生的`javascript`对象去描述一个 `Dom`节点。是对真实`Dom`的一层抽象。

由于在 浏览器中操作 `Dom`是昂贵的，频繁的操作`Dom`，会产生一定的性能问题，因此我们需要一层抽象，在`patch`过程中尽可能地一次性将差异更新到`Dom`中，这样保证了`Dom`不会出现性能很差的情况。

另外更重要的一点也是虚拟`Dom`的设计初衷，为了更好的跨平台，比如 `Node.js`就没有`Dom`，如果想实现`SSR(服务端渲染)`,那么一个方式就是借助 虚拟`Dom`，因为虚拟`Dom`本身就是 `Javascript`对象。

### 为什么不推荐直接操作`Dom`

-  DOM修改导致的页面重绘、重新排版！重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨！浪费资源影响性能。 

- 破坏了代码模块化结构导致代码腐化

  组件原本可以控制哪些`dom`操作可以对外暴漏（即对应methods 中的方法）,但直接操作`dom`跳过了这个控制，导致这些方法搁置不被使用，随着项目越来越大，这样的操作行为如果越来越多，会导致后期定位直接操作`dom`导致的问题耗时会成指数级上升

- 过多的直接操作`dom`行为会增加代码的耦合性

  当包含直接操作`dom`行为的组件在别处使用时，直接操作`dom`的代码有可能不可用。

  如果直接操作`dom`的代码没有检查`dom`状态或没有精准捕获想要操作的`dom`时，则直接复用可能导致不可预料的后果，即意味着这个组件只能在特定的位置和场景中使用，耦合性提高，复用性下降

- 操作不属于自己的`dom`时，`dom`状态无法预知

  `dom`归属于其他组件时，`dom`可能没有生成，也有可能`dom`所属组件并没有被加载或使用。*

  如`dom`所在组件用v-if控制了`dom`的隐藏/显示，这样就必须在操作`dom`之前判断`dom`的状态，增加了冗余代码；

  *组件状态的变化可能导致获取到的`dom`不是预想的`dom`。*

