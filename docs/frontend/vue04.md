## 你对MVVM的理解？

### MVVM 是什么？
MVVM 模式，顾名思义即 Model-View-ViewModal 模式。它萌芽于2005年微软推出的基于 windows 的用户界面框架 WPF ，前端最早的 MVVM框架 knockout 在2010年发布。

- Model层：对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等API 完成客户端 和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的Model

- View层：作为试图模板存在，在MVVM里，整个View 是一个动态模板。除了定义结构、布局外，他展示的是ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、指令的声明、事件绑定的声明。

- ViewModel层：把 View 层需要的层数据暴露，并对 View 层的数据绑定声明、指令声明、事件绑定声明负责，也就是处理View 层的具体业务。ViewModel 底层会做好绑定属性的监听。当ViewModel 中数据变化，View 层会得到更新；而当View中声明了数据的双向绑定（通常是表单元素），框架也会监听View层（表单）的值的变化。一旦值变化，View层绑定的ViewModel中的数据也会得到自动更新。

   ![2019-07-16-21-47-05](../.vuepress/public/img/frontend/d55fe97b6ef63370645754e1d4a760b6.png) 

### MVVM的优缺点？
**优点**

- 1.分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的"View"上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑

- 2 提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码

- 3 自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放

**缺点**

- 1、Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的

- 2、一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存

- 3、对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高

## Vue-Router  中的 hash 模式 和 history 模式的区别

- 最明显的显性区别： `hash`模式的 `url`中会夹杂着 `#`符号，而 `history`模式没有

- 底层实现不同：

  `hash`模式 是基于 浏览器的 `onhashchange`事件（监听 `location.hash`的改变）实现

  `history`模式是基于 `HTML5 history`新提供的两个方法：`pushState()`可以改变`url`地址且不会发送请求，`replaceState()`方法可以读取历史记录栈，还可以对浏览器记录进行修改 

  

## 介绍一下虚拟DOM

虚拟 `Dom` 本质就是用一个原生的`javascript`对象去描述一个 `Dom`节点。是对真实`Dom`的一层抽象。

由于在 浏览器中操作 `Dom`是昂贵的，频繁的操作`Dom`，会产生一定的性能问题，因此我们需要一层抽象，在`patch`过程中尽可能地一次性将差异更新到`Dom`中，这样保证了`Dom`不会出现性能很差的情况。

另外更重要的一点也是虚拟`Dom`的设计初衷，为了更好的跨平台，比如 `Node.js`就没有`Dom`，如果想实现`SSR(服务端渲染)`,那么一个方式就是借助 虚拟`Dom`，因为虚拟`Dom`本身就是 `Javascript`对象。

### 为什么不推荐直接操作`Dom`

-  DOM修改导致的页面重绘、重新排版！重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨！浪费资源影响性能。 

- 破坏了代码模块化结构导致代码腐化

  组件原本可以控制哪些`dom`操作可以对外暴漏（即对应methods 中的方法）,但直接操作`dom`跳过了这个控制，导致这些方法搁置不被使用，随着项目越来越大，这样的操作行为如果越来越多，会导致后期定位直接操作`dom`导致的问题耗时会成指数级上升

- 过多的直接操作`dom`行为会增加代码的耦合性

  当包含直接操作`dom`行为的组件在别处使用时，直接操作`dom`的代码有可能不可用。

  如果直接操作`dom`的代码没有检查`dom`状态或没有精准捕获想要操作的`dom`时，则直接复用可能导致不可预料的后果，即意味着这个组件只能在特定的位置和场景中使用，耦合性提高，复用性下降

- 操作不属于自己的`dom`时，`dom`状态无法预知

  `dom`归属于其他组件时，`dom`可能没有生成，也有可能`dom`所属组件并没有被加载或使用。*

  如`dom`所在组件用v-if控制了`dom`的隐藏/显示，这样就必须在操作`dom`之前判断`dom`的状态，增加了冗余代码；

  *组件状态的变化可能导致获取到的`dom`不是预想的`dom`。*

